# GCP環境 構築手順書

| 項目 | 内容 |
|------|------|
| 対象者 | 非エンジニア |
| 作業時間 | 約1〜2時間 |

---

## 事前準備チェック

| チェック | 項目 |
|:------:|------|
| ☐ | Googleアカウント（管理者権限） |
| ☐ | クレジットカード（GCP課金用） |
| ☐ | AIのAPIキー（OpenAI等） |

---

## 全体構成

### 仕組みの概要

```
あなた（ブラウザ）
    |
    | (1) アクセス
    v
Cloud Run functions
    |
    | (2) ログインしてる？
    v
Firebase Auth（認証） ←── Googleアカウントでログイン
    |
    | (3) ログイン済みならOK
    v
Cloud Run functions
    |
    | (4) APIキーを取得
    v
Secret Manager（鍵の金庫）
    |
    | (5) AI に質問
    v
OpenAI API（ChatGPT）
    |
    | (6) 回答
    v
あなた（ブラウザ）に表示
```

### 何を作るか

| 作るもの | 役割 | 個数 |
|---------|------|:----:|
| Firebase プロジェクト | Googleログイン認証 | 1つ |
| Cloud Run functions | チャット画面の表示 + AI呼び出し | 1つ |
| Secret Manager のシークレット | APIキーの保管 | 1つ |

### なぜこの構成？

| 特徴 | 説明 |
|------|------|
| 認証あり | Googleアカウントでログインした人だけ使える |
| シンプル | 作成するのは**3つだけ** |
| 安全 | APIキーは暗号化して保管（コードに書かない） |
| 無料枠あり | 少量アクセスなら無料枠内で運用可能 |

> **コストについて**
>
> | サービス | 無料枠 | 超過時の課金 |
> |---------|-------|-------------|
> | Firebase Auth | 月5万認証まで無料 | ほぼ無料で収まる |
> | Cloud Run functions | 月200万リクエストまで無料 | リクエスト数に応じて課金 |
> | Secret Manager | 月6シークレット・6,000アクセスまで無料 | 微量課金 |
> | **OpenAI API** | **無料枠なし** | **利用量に応じて課金** |
>
> **注意**: Firebase/GCPは無料枠がありますが、**OpenAI等の外部AI APIは従量課金**です。
> テスト段階では数円〜数十円程度ですが、本番運用時はAPI利用料金が発生します。

---

## Step 1: Firebaseプロジェクト作成（15分）

> **FirebaseとGCPの関係**
>
> Firebaseでプロジェクトを作成すると、**GCPプロジェクトも自動的に作成**されます。
> 別々に作成する必要はありません。
>
> ```
> Firebaseでプロジェクト作成
>     ↓
> 自動的にGCPプロジェクトも作成される
>     ↓
> 両方のコンソールで同じプロジェクトを操作できる
> ```
>
> | コンソール | URL | 用途 |
> |-----------|-----|------|
> | Firebase | console.firebase.google.com | 認証（Auth）、ウェブアプリ設定 |
> | GCP | console.cloud.google.com | Cloud Run functions、Secret Manager |

### 1-1. Firebaseプロジェクト作成

1. https://console.firebase.google.com にアクセス
2. Googleアカウントでログイン
3. 「**プロジェクトを作成**」をクリック

> **「プロジェクトを追加」と表示される場合**
> 既にFirebaseプロジェクトがある場合は「プロジェクトを追加」と表示されます。
> どちらも同じ操作です。

4. プロジェクト名を入力（例: `ai-chat-app`）
   - この名前がGCPプロジェクト名にもなります
   - プロジェクトIDは自動生成されます（例: `ai-chat-app-89fe2`）

5. 「続行」をクリック

6. Googleアナリティクス: 今回は「**このプロジェクトでGoogleアナリティクスを有効にする**」を**オフ**にする
   - テスト環境では不要です
   - 後から有効化することも可能です

7. 「**プロジェクトを作成**」をクリック

8. 「新しいプロジェクトの準備ができました」と表示されたら「**続行**」をクリック

### 1-2. プロジェクトIDの確認

作成後、プロジェクトIDを確認しておきます（後で使用します）。

1. 左上の**歯車アイコン（⚙️）**をクリック
2. 「**プロジェクトの設定**」をクリック
3. 以下の情報をメモしておく:

| 項目 | 例 | 用途 |
|------|-----|------|
| プロジェクト名 | `ai-chat-app` | 表示名 |
| プロジェクトID | `ai-chat-app-89fe2` | GCPでの識別に使用 |

> **GCPコンソールでの確認方法**
>
> https://console.cloud.google.com にアクセスすると、
> 画面上部のプロジェクト選択で先ほど作成したプロジェクト（例: `ai-chat-app-89fe2`）が
> 表示されていることを確認できます。

---

## Step 2: Firebase Authentication設定（10分）

> **Firebase Authとは？**
> Googleが提供する認証サービスです。
> 「Googleアカウントでログイン」ボタンを簡単に実装できます。
>
> | メリット | 説明 |
> |---------|------|
> | 簡単 | 数行のコードでログイン機能が完成 |
> | 安全 | パスワード管理はGoogleにお任せ |
> | 無料 | 月5万人まで無料 |

### 2-1. Authentication有効化

1. Firebaseコンソールの左メニューから「**構築**」を展開
2. 「**Authentication**」をクリック
3. 「**始める**」をクリック

> **画面が異なる場合**
> 既にAuthenticationが有効な場合は「始める」ボタンは表示されません。
> その場合は次の手順に進んでください。

### 2-2. Googleログインを有効化

1. 「**ログイン方法**」タブをクリック
2. 「**新しいプロバイダを追加**」をクリック
3. 「**Google**」を選択

4. 以下を設定:
   | 項目 | 設定 |
   |------|------|
   | 有効にする | **オン**（トグルをクリック） |
   | プロジェクトのサポートメール | 自分のメールアドレスを選択 |

5. 「**保存**」をクリック

> **設定完了後の画面**
>
> | プロバイダ | ステータス |
> |-----------|-----------|
> | Google | 有効 |
>
> と表示されていればOKです。

### 2-3. ウェブアプリを登録

Firebase設定情報を取得するため、ウェブアプリを登録します。

1. 左上の**家アイコン**（プロジェクトの概要）をクリックしてトップページに戻る
2. 「**＋ アプリを追加**」ボタンをクリック

> **「＋ アプリを追加」が見つからない場合**
> プロジェクトの概要ページで、プロジェクト名の下に
> 「アプリを追加してください」というメッセージがあります。
> そこから追加することもできます。

3. プラットフォームの選択画面で「**ウェブ**」（ウェブアイコン）をクリック

4. アプリ情報を入力:
   | 項目 | 入力値 |
   |------|--------|
   | アプリのニックネーム | `ai-chat-web`（任意の名前） |
   | Firebase Hosting | チェック**しない**（今回は不要） |

> **Firebase Hosting とは？**
> Firebaseが提供する**静的ウェブサイトのホスティングサービス**です。
> HTML/CSS/JavaScriptファイルを置くだけでウェブサイトを公開できます。
> 今回はCloud Run functionsでフロントエンドも配信するため、Firebase Hostingは使用しません。

5. 「**アプリを登録**」をクリック

6. 「**Firebase SDK の追加**」画面が表示されます
   - 表示される `firebaseConfig` の内容を**メモまたはコピー**しておく

> **SDK（エスディーケー）とは？**
> **Software Development Kit**の略で、「開発用の道具セット」という意味です。
> Firebaseの機能（ログイン機能など）をアプリから簡単に使うための部品集です。
> ここで表示される `firebaseConfig` は、あなたのプロジェクト専用の接続情報です。

```javascript
// この情報は後でコードに貼り付けます（値は各プロジェクトで異なります）
const firebaseConfig = {
  apiKey: "AIzaSyXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
  authDomain: "ai-chat-app-89fe2.firebaseapp.com",
  projectId: "ai-chat-app-89fe2",
  storageBucket: "ai-chat-app-89fe2.appspot.com",
  messagingSenderId: "123456789012",
  appId: "1:123456789012:web:xxxxxxxxxxxxxxxxxx"
};
```

7. 「**コンソールに進む**」をクリック

> **後からfirebaseConfigを確認する方法**
>
> 1. 歯車アイコン（⚙️）→「プロジェクトの設定」
> 2. 「全般」タブの下部「マイアプリ」セクション
> 3. 登録したウェブアプリをクリック
> 4. 「SDK の設定と構成」で確認できます

---

## Step 3: GCP API有効化（5分）

Cloud Run functionsとSecret Managerを使用するために、GCPで必要なAPIを有効化します。

### 3-1. GCPコンソールにアクセス

1. https://console.cloud.google.com にアクセス
2. 画面上部のプロジェクト選択で、**Firebaseで作成したプロジェクト**を選択
   - 例: `ai-chat-app-89fe2`

> **プロジェクトが見つからない場合**
> プロジェクト選択画面で「すべて」タブを確認してください。
> Firebaseで作成したプロジェクトは自動的にGCPにも表示されます。

### 3-2. API有効化

1. 左メニュー「**APIとサービス**」→「**ライブラリ**」をクリック
2. 以下のAPIを**それぞれ検索して有効化**:

| API名 | 検索ワード | 用途 |
|-------|-----------|------|
| Cloud Run Admin API | `Cloud Run` | Cloud Run functionsの作成・管理 |
| Cloud Build API | `Cloud Build` | コードのビルド |
| Secret Manager API | `Secret Manager` | APIキーの安全な保管 |

**各APIの有効化手順:**
1. 検索バーにAPI名を入力
2. 検索結果からAPIをクリック
3. 「**有効にする**」ボタンをクリック
4. 有効化が完了するまで待つ（数秒〜1分程度）

> **既に有効な場合**
> 「有効にする」ではなく「管理」と表示されている場合は、既に有効です。
> 何もせず次のAPIに進んでください。

---

## Step 4: Secret Manager設定（10分）

### 4-1. APIキー保存

> **Secret Managerとは？**
> AIサービス（OpenAI等）のAPIキーを**安全に暗号化して保管**するためのサービスです。
>
> | 保存方法 | 問題点 |
> |---------|--------|
> | コードに直接書く | GitHubに漏洩 → 不正利用で高額請求 |
> | 環境変数に直接設定 | GCPコンソール画面に**平文で丸見え** |
> | **Secret Manager** | 暗号化保存 + アクセス権限管理 |

1. GCPコンソール →「Secret Manager」→「シークレットを作成」
2. 名前: `openai-api-key`
3. シークレットの値: OpenAIのAPIキーを入力
4. 「シークレットを作成」

> **【命名規則の推奨】マルチテナント運用時**
>
> 複数のクライアント（テナント）を管理する場合、シークレット名に**テナントIDをプレフィックス**として付けることを強く推奨します。
>
> | 構成 | 命名規則 | 例 |
> |------|---------|-----|
> | シングルテナント（1社のみ） | `{用途}` | `openai-api-key` |
> | マルチテナント（複数社） | `{テナントID}-{用途}` | `companya-openai-key` |
>
> ```
> 【マルチテナントの場合のSecret Manager一覧】
>
> companya-openai-key      ← A社用のOpenAI APIキー
> companya-anthropic-key   ← A社用のAnthropic APIキー
> companyb-openai-key      ← B社用のOpenAI APIキー
> companyc-dify-key        ← C社用のDify APIキー
>
> → プレフィックスでどのテナントか一目瞭然！
> ```
>
> **なぜ命名規則が重要か？**
> - シークレットが増えると「どれがどのクライアント用か」が分からなくなる
> - 誤って別テナントのAPIキーを紐付けるリスクを防止
> - 管理画面での検索・フィルタリングが容易になる

> **【テスト環境の場合】**
> 実際のAPIキーがない場合は、以下のダミー値で手順を練習できます：
> ```
> sk-test-dummy-key-12345
> ```
> ※ ダミー値ではAI機能は動作しませんが、環境構築の手順確認には使用できます。

### 4-2. サービスアカウントへの権限付与

シークレットを作成したら、Cloud Runがシークレットにアクセスできるように権限を付与します。

> **⚠️ この手順を忘れると？**
>
> Cloud Runデプロイ時に以下のエラーが発生します：
>
> ```
> Permission denied on secret: projects/xxx/secrets/openai-api-key/versions/latest
> for Revision service account xxx@xxx.iam.gserviceaccount.com.
> The service account used must be granted the 'Secret Manager Secret Accessor' role
> ```

**権限付与の手順**

1. GCPコンソールで「**IAMと管理**」→「**IAM**」を開く
2. 使用するサービスアカウントを探す
   - 推奨: `firebase-adminsdk-xxxxx@[プロジェクトID].iam.gserviceaccount.com`
   - ※ `xxxxx` と `[プロジェクトID]` は各プロジェクトで異なります
3. 右の**鉛筆アイコン（編集）**をクリック
4. 「**別のロールを追加**」をクリック
5. 「`Secret Manager Secret Accessor`」または「`Secret Manager のシークレット アクセサー`」を検索して選択
6. 「**保存**」をクリック

> **どのサービスアカウントに権限を付与するか？**
>
> | サービスアカウント | 説明 |
> |------------------|------|
> | `firebase-adminsdk-xxxxx@...`（推奨） | Firebase関連の権限も持っている。Step 5でCloud Runに設定する |
> | `xxxxx-compute@developer.gserviceaccount.com` | デフォルトのCompute Engine サービスアカウント |
>
> **推奨**: `firebase-adminsdk` を使用し、Step 5のセキュリティタブでこのサービスアカウントを選択します。

---

## Step 5: Cloud Run functions作成（30分）

> **Cloud Run functions とは？**
> コードを書くだけでサーバーなしで動くWebアプリを作れるサービスです。
>
> | 従来の方法 | Cloud Run functions |
> |-----------|---------------------|
> | サーバーを借りる → OS設定 → Node.js入れる → アプリ設置 | コードを貼り付け → 動く！ |
>
> **名称について**
> 以前は「Cloud Functions」という名前でしたが、現在は「Cloud Run functions」に名称変更されました。
> GCPコンソールでは「Cloud Run」→「関数を作成」から利用します。
>
> **補足: コンテナイメージについて**
> Cloud Run functions版では、コードを貼り付けるだけでGCPが自動的に実行環境を用意してくれます。
> そのため、Dockerやコンテナイメージの知識は不要です。
> 「コンテナイメージとは何か？」を知りたい方は [99_container.md](99_container.md) を参照してください。

### 5-1. 関数の作成を開始

1. GCPコンソール（https://console.cloud.google.com）を開く
2. 左側メニューから「Cloud Run」をクリック
3. 上部の「＋ 関数を作成」ボタンをクリック

> **「関数を作成」が見つからない場合**
> 「＋ サービスを作成」ではなく「＋ 関数を作成」を選んでください。
> 見つからない場合は、検索バーで「Cloud Run functions」と検索してください。

### 5-2. 基本情報の設定（画面上部）

画面の上から順に設定していきます。

#### サービス名とリージョン

| 項目 | 設定値 | 意味 |
|------|--------|------|
| サービス名 | `ai-chat-app` | この関数を識別する名前（半角英数字とハイフンのみ） |
| リージョン | `asia-northeast1（東京）` | サーバーの場所。日本のユーザー向けなら東京を選択 |

> **リージョンとは？**
> サーバーが物理的に設置されている場所です。
> ユーザーに近いリージョンを選ぶと、応答速度が速くなります。
>
> | リージョン | 場所 | 用途 |
> |-----------|------|------|
> | asia-northeast1 | 東京 | 日本国内向け（推奨） |
> | asia-northeast2 | 大阪 | 東京のバックアップ |
> | us-central1 | アイオワ | 海外向け・コスト重視 |

#### ランタイム

| 項目 | 設定値 | 意味 |
|------|--------|------|
| ランタイム | `Node.js 24` または `Node.js 20` | プログラムの実行環境（言語とバージョン） |

#### トリガー（省略可）

「＋ トリガーを追加」をクリックして、HTTPSトリガーを設定します。
（省略した場合もHTTPSトリガーが自動で設定されます）

#### 認証（重要）

| 項目 | 設定値 | 意味 |
|------|--------|------|
| 認証 | **公開アクセスを許可する** | 誰でもURLにアクセス可能 |

> **「公開アクセスを許可する」を選択する理由**
>
> ```
> 2段階の認証になっています：
>
> ┌─────────────────────────────────────────────────┐
> │ 1段階目: Cloud Run の認証（GCPレベル）            │
> │                                                 │
> │   「公開アクセスを許可する」                       │
> │   = 誰でもURLにアクセスできる                     │
> │   = ログイン画面を表示するため、ここは許可が必要    │
> │                                                 │
> │   ※「認証が必要」を選ぶと、GCPアカウントがないと   │
> │     ログイン画面すら見れなくなってしまう           │
> └─────────────────────────────────────────────────┘
>                       ↓
> ┌─────────────────────────────────────────────────┐
> │ 2段階目: アプリ側の認証（Firebase Auth）          │
> │                                                 │
> │   ログイン画面で「Googleでログイン」ボタンを押す   │
> │   → ログインした人だけがチャット機能を使える      │
> │                                                 │
> │   ※ここで本当のアクセス制限をかけている           │
> └─────────────────────────────────────────────────┘
>
> つまり：
> ・ログイン画面は誰でも見れる（1段階目は許可）
> ・チャット機能はログインした人だけ使える（2段階目で制限）
> ```

#### 課金

| 項目 | 設定値 | 意味 |
|------|--------|------|
| 課金 | **リクエスト ベース** | リクエストがあった時だけ課金される（推奨） |

> **課金方式の違い**
> | 方式 | 説明 | 適したケース |
> |------|------|-------------|
> | リクエスト ベース | リクエストがない時はCPUが制限される。使った分だけ課金 | テスト環境、アクセス少なめ（推奨） |
> | インスタンス ベース | インスタンスが起動している間ずっと課金 | 常時高負荷、応答速度重視 |

#### サービスのスケーリング（画面上部）

| 項目 | 設定値 | 意味 |
|------|--------|------|
| スケーリング | **自動スケーリング** | アクセス量に応じて自動で増減（推奨） |
| インスタンスの最小数 | `0` | アクセスがない時に起動しておくインスタンスの数 |
| インスタンスの最大数 | `10`（または空欄） | 同時に起動できるインスタンスの上限 |

> **インスタンスとは？**
>
> 「インスタンス」とは、アプリが動いている**仮想的なサーバー1台**のようなものです。
>
> ```
> ┌─────────────────────────────────────────────────┐
> │                  分かりやすい例え                  │
> │                                                 │
> │     インスタンス = ファストフード店のレジ係         │
> │                                                 │
> │     ・お客さん数人 → レジ係1人で対応できる         │
> │     ・お客さん100人が殺到                        │
> │       → レジ係を10人に増やして対応（自動！）      │
> │     ・お客さん0人（深夜など）                     │
> │       → レジ係を帰宅させてコスト削減             │
> └─────────────────────────────────────────────────┘
> ```
>
> **⚠️ 注意: インスタンス1台 ≠ ユーザー1人 ではありません！**
>
> 1つのインスタンスは**複数のリクエストを同時に処理**できます。
> 何人まで同時に処理できるかは、次の「リクエスト」セクションで設定します。
> （デフォルトは80リクエスト/インスタンス）
>
> ```
> 【計算例】
> インスタンス最大数: 10
> 1インスタンスあたり: 80リクエスト
>     ↓
> 最大 10 × 80 = 800リクエストを同時に処理可能
> ```

> **「1に設定するとコールド スタートが減少します」とは？**
>
> | 設定 | 動作 | メリット | デメリット |
> |------|------|---------|-----------|
> | 最小=0 | アクセスがないとインスタンス停止 | **コスト0円**（使った時だけ課金） | 初回アクセスが遅い（2〜5秒待つ） |
> | 最小=1 | 常に1台は起動しておく | 常に高速応答 | **常時課金が発生**（月$5〜10程度） |
>
> ```
> 【最小=0 の場合（コールドスタート）】
>
> ユーザーがアクセス
>     ↓
> インスタンスが停止中...（誰もいない店）
>     ↓
> 起動開始（店を開けて準備中）
>     ↓
> 2〜5秒後に応答 ← この待ち時間が「コールドスタート」
>
>
> 【最小=1 の場合（ウォームスタート）】
>
> ユーザーがアクセス
>     ↓
> インスタンスは起動済み！（店はすでに営業中）
>     ↓
> すぐに応答
> ```
>
> **テスト環境では最小=0、本番で応答速度が重要なら最小=1以上を検討してください。**

### 5-3. コンテナ、ネットワーキング、セキュリティの設定

画面下部にある「コンテナ、ネットワーキング、セキュリティ」をクリックして展開します。

#### 「コンテナ」タブ → 「コンテナの編集」

##### 設定タブ

###### リソース

| 項目 | 設定値 | 意味 |
|------|--------|------|
| メモリ | `512 MiB` | アプリが使えるメモリ量。AI処理には512MB以上推奨 |
| CPU | `1` | 処理能力。通常は1で十分 |

> **メモリとCPUの関係**
> ```
> メモリ = 机の広さ（作業スペース）
> CPU = 作業する人の数と速さ
>
> AI処理では多くのデータを一時的に保持するため、
> 机（メモリ）が広い方が効率よく処理できます。
> ```

###### リクエスト

| 項目 | 設定値 | 意味 |
|------|--------|------|
| リクエストのタイムアウト | `300` 秒 | 1リクエストの最大処理時間 |
| インスタンスあたりの最大同時リクエスト数 | `80`（デフォルト） | 1つのインスタンスが同時に処理できるリクエスト数 |

> **タイムアウトとは？**
> ```
> ユーザーがAIに質問
>     ↓
> AIが考え中...（最大300秒まで待つ）
>     ↓
> 300秒を超えると強制終了（エラー）
>
> AIの応答は数秒〜30秒程度かかることがあるため、
> 余裕を持って300秒（5分）に設定しています。
> ```

###### 実行環境

| 項目 | 設定値 | 意味 |
|------|--------|------|
| 実行環境 | **デフォルト** | Cloud Runが最適な環境を自動選択 |

> **実行環境の選択肢**
> | 選択肢 | 説明 |
> |--------|------|
> | デフォルト | Cloud Runが自動で最適な環境を選ぶ（推奨） |
> | 第1世代 | コールドスタートが速い（シンプルな処理向け） |
> | 第2世代 | 高性能、ネットワークファイルシステム対応（複雑な処理向け） |

###### リビジョン スケーリング

「リビジョン スケーリング」セクションで以下を設定：

| 項目 | 設定値 | 意味 |
|------|--------|------|
| **インスタンスの最小数** | `0` | このリビジョンで起動しておくインスタンスの最小数 |
| **インスタンスの最大数** | `10` | このリビジョンで起動できるインスタンスの上限 |

> **「サービスのスケーリング」と「リビジョン スケーリング」の違い**
>
> ```
> ┌─────────────────────────────────────────────────┐
> │ サービスのスケーリング（画面上部）                 │
> │                                                 │
> │   サービス全体のインスタンス数を設定              │
> │   → 通常はこちらで設定すればOK                   │
> └─────────────────────────────────────────────────┘
>                       ↓
> ┌─────────────────────────────────────────────────┐
> │ リビジョン スケーリング（コンテナ設定内）          │
> │                                                 │
> │   特定のリビジョン（バージョン）のインスタンス数   │
> │   → 複数バージョンを同時運用する場合に使用        │
> │   → 通常は上部の設定と同じ値でOK                 │
> └─────────────────────────────────────────────────┘
> ```

> **リビジョンとは？**
> ```
> リビジョン = アプリのバージョン
>
> コードを変更してデプロイするたびに、新しいリビジョンが作成されます。
>
> リビジョン1（古い） ← 問題があれば戻せる
>     ↓
> リビジョン2（新しい） ← 現在稼働中
> ```
>
> ※ インスタンスについては「サービスのスケーリング」（4-2）で説明しています。

##### 変数とシークレット タブ

「変数とシークレット」タブをクリックします。

###### 環境変数

「＋ 変数を追加」をクリックして、以下の環境変数を追加します。

| 名前 | 値の例 | 意味 |
|------|--------|------|
| `ALLOWED_EMAILS` | `user1@example.com,user2@example.com` | ログインを許可するメールアドレス（カンマ区切り） |
| `ALLOWED_DOMAINS` | `@yourcompany.co.jp` | ログインを許可するドメイン（カンマ区切り） |

> **環境変数とは？**
>
> アプリに渡す「設定値」のことです。コードの中身を変えずに、動作を変更できます。
>
> ```
> 【環境変数のイメージ】
>
> コード（変えない）        環境変数（変える）
>       ↓                       ↓
> 「許可リストをチェック」  →  許可リスト = "user1@example.com"
>
> ※ 許可するユーザーを追加したい時、コードは変えずに
>    環境変数だけ変更すればOK
> ```

---

> **ALLOWED_EMAILS と ALLOWED_DOMAINS の詳細説明**
>
> この2つの環境変数で「誰がこのアプリを使えるか」を制限できます。
>
> **① ALLOWED_EMAILS（個別メールアドレス指定）**
>
> | 設定値の例 | 許可されるユーザー |
> |-----------|------------------|
> | `admin@example.com` | admin@example.com のみ |
> | `admin@example.com,user1@gmail.com` | 2人のみ（カンマ区切りで複数指定可能） |
>
> **② ALLOWED_DOMAINS（ドメイン指定）**
>
> | 設定値の例 | 許可されるユーザー |
> |-----------|------------------|
> | `@yourcompany.co.jp` | `xxx@yourcompany.co.jp` のメールを持つ全員 |
> | `@yourcompany.co.jp,@partner.co.jp` | 2つの会社の全員（カンマ区切りで複数指定可能） |
>
> **③ 両方設定した場合**
>
> 「どちらかに該当すれば許可」されます（OR条件）。
>
> ```
> 例：
> ALLOWED_EMAILS = "external-user@gmail.com"
> ALLOWED_DOMAINS = "@yourcompany.co.jp"
>
> 許可されるユーザー：
> ✓ tanaka@yourcompany.co.jp   ← ドメインが一致
> ✓ suzuki@yourcompany.co.jp   ← ドメインが一致
> ✓ external-user@gmail.com    ← メールアドレスが一致
> ✗ other@gmail.com            ← どちらにも該当しない
> ```
>
> **④ 片方だけ設定する場合**
>
> | やりたいこと | 設定方法 |
> |-------------|---------|
> | 会社のドメインだけで縛りたい | `ALLOWED_DOMAINS` だけ設定する（`ALLOWED_EMAILS` は空欄または未設定） |
> | 特定の人だけ許可したい | `ALLOWED_EMAILS` だけ設定する（`ALLOWED_DOMAINS` は空欄または未設定） |
> | 両方組み合わせたい | 両方設定する |
>
> **⑤ 両方とも未設定の場合**
>
> **全員がログイン可能になります**（開発・テスト用）。
> 本番環境では必ずどちらかを設定してください。

---

> **なぜ環境変数でアクセス制限ができるのか？（仕組みの解説）**
>
> ```
> 【処理の流れ】
>
> 1. ユーザーがGoogleでログインする
>        ↓
> 2. Googleから「この人は tanaka@yourcompany.co.jp です」という情報が返ってくる
>        ↓
> 3. フロントエンド（front.html）がバックエンド（backend.js）に確認リクエストを送る
>    「このメールアドレスの人は使っていいですか？」
>        ↓
> 4. バックエンド（backend.js）が環境変数をチェック
>    ・ALLOWED_EMAILS に含まれているか？ → NO
>    ・ALLOWED_DOMAINS で終わっているか？ → YES（@yourcompany.co.jp で終わる）
>        ↓
> 5. 結果を返す
>    ・許可 → チャット画面を表示
>    ・拒否 → 「アクセスが許可されていません」画面を表示
> ```
>
> **コード内の該当部分（backend.js）**
>
> ```javascript
> // メールアドレスが許可されているかチェックする関数
> function isEmailAllowed(email) {
>     // 1. ALLOWED_EMAILS に含まれているかチェック
>     if (allowedEmails.includes(email)) {
>         return true;  // 許可
>     }
>
>     // 2. ALLOWED_DOMAINS のどれかで終わっているかチェック
>     for (const domain of allowedDomains) {
>         if (email.endsWith(domain)) {  // endsWith = 「〜で終わる」
>             return true;  // 許可
>         }
>     }
>
>     return false;  // どちらにも該当しない → 拒否
> }
> ```
>
> このように、**ログイン後にメールアドレスをチェックする処理がコードに組み込まれている**ため、
> 環境変数を変更するだけでアクセス制限を変更できます。

---

> **シークレットとの違い**
>
> | 種類 | 用途 | 画面での見え方 |
> |------|------|--------------|
> | 環境変数 | 一般的な設定値 | **そのまま見える**（例: `user@example.com`） |
> | シークレット | APIキーなど機密情報 | **隠される**（例: `••••••••`） |
>
> メールアドレスやドメイン名は機密情報ではないので「環境変数」を使います。
> APIキーなど漏れてはいけない情報は「シークレット」を使います。

###### 環境変数として公開されるシークレット

1. 「＋ シークレットを参照」をクリック
2. 以下を設定:

| 項目 | 設定値 | 意味 |
|------|--------|------|
| 名前1 | `OPENAI_API_KEY` | コード内で使う環境変数名 |
| シークレット | `openai-api-key` を選択 | Step 3で作成したシークレット |
| バージョン | `1` または `latest` | シークレットのバージョン |

3. 「完了」をクリック

> **なぜシークレットを使うのか？**
>
> | 方法 | 問題点 |
> |------|--------|
> | コードに直接APIキーを書く | GitHubなどに漏洩するリスク大 |
> | 普通の環境変数に設定 | GCP画面に**平文で丸見え** |
> | **シークレットを使う** | 暗号化されて安全に保管 ✓ |
>
> **この画面でやっていること（3つの設定）**
>
> | 項目 | 設定値 | 意味 |
> |------|--------|------|
> | **名前** | `OPENAI_API_KEY` | コード内で使う「呼び名」（変数名） |
> | **シークレット** | `openai-api-key` | Step 3で作った「金庫の中身」 |
> | **バージョン** | `latest` | シークレットのどのバージョンを使うか |
>
> **イメージ**
> ```
> 金庫（Secret Manager）の中身 → 呼び名（環境変数）をつけて渡す
>
>  openai-api-key        →  OPENAI_API_KEY という名前で
> 「sk-xxxxx...」            アプリに渡す
> ```
>
> こうすることで、コード内では `process.env.OPENAI_API_KEY` と書くだけで、
> 安全に保管されたAPIキーを使えるようになります。
>
> **補足: サービスアカウントについて**
> Cloud Run functionsでは、デフォルトのサービスアカウントが自動的に使用されます。
> サービスアカウントとは「アプリ専用のGoogleアカウント」のようなもので、
> アプリがSecret Managerにアクセスするための権限を持っています。
> 詳しくは [99_service_account.md](99_service_account.md) を参照してください。

4. 「コンテナを保存」をクリック

##### セキュリティ タブ

「セキュリティ」タブをクリックして、サービスアカウントを設定します。

| 項目 | 設定値 | 意味 |
|------|--------|------|
| サービス アカウント | `firebase-adminsdk-xxxxx@[プロジェクトID].iam.gserviceaccount.com` | Step 4-2で権限を付与したサービスアカウント |

> **注意**: Step 4-2 で権限付与したサービスアカウントを選択してください。
> `Default compute service account` のままだとシークレットへのアクセス権限エラーが発生します。

### 5-4. ソースコードの設定

「ソース」セクションで以下を設定：

#### ソースの場所

| 項目 | 設定値 | 意味 |
|------|--------|------|
| ソースの場所 | **インラインエディタ** | GCPコンソール上で直接コードを入力 |

#### エントリポイント

| 項目 | 設定値 | 意味 |
|------|--------|------|
| エントリポイント | `app` | 最初に呼び出される関数名 |

> **エントリポイントとは？**
> プログラムの「入口」です。
> リクエストが来た時に最初に実行される関数の名前を指定します。
> コード内の `functions.http('app', ...)` の `'app'` と一致させる必要があります。

#### ソースコード

> **言語の選択**
>
> Node.js版とPython版を用意しています。どちらでも同じ機能が動作します。
>
> | 言語 | ソースコード | 特徴 |
> |------|---------|------|
> | **Node.js**（推奨） | [コードを見る](../code/nodejs/index.md) | JavaScript。ウェブ開発で最も一般的 |
> | Python | [コードを見る](../code/python/index.md) | AIや機械学習でよく使われる言語 |
>
> 以下の手順は**Node.js版**で説明します。Python版を使う場合は、ランタイムを「Python 3.11」に変更し、`main.py`にbackend.pyの内容を貼り付けてください。

> **ファイル構成（Node.js版）**
>
> | ファイル | 役割 | GCPでの操作 |
> |---------|------|------------|
> | [front.html](../code/nodejs/front.md) | 画面のデザイン（HTML/CSS） | 新規ファイルとして追加 |
> | [script.js](../code/nodejs/script.md) | フロントエンドの処理（JavaScript） | 新規ファイルとして追加 |
> | [backend.js](../code/nodejs/backend.md) | サーバー側の処理 | index.js に貼り付け |
> | [package.json](../code/nodejs/package.md) | 使用するライブラリ一覧 | package.json に貼り付け |

##### GCPへの貼り付け手順

**1. index.js を設定**

1. 左側のファイル一覧で「index.js」をクリック
2. 既存のコードをすべて削除
3. [backend.js](../code/nodejs/backend.md) の内容をコピーして貼り付け

**2. front.html を追加**

1. 左側のファイル一覧の上にある「**＋**」ボタンをクリック
2. ファイル名に「`front.html`」と入力
3. [front.html](../code/nodejs/front.md) の内容をコピーして貼り付け

**3. script.js を追加**

1. 左側のファイル一覧の上にある「**＋**」ボタンをクリック
2. ファイル名に「`script.js`」と入力
3. [script.js](../code/nodejs/script.md) の内容をコピーして貼り付け

> **重要: Firebase設定の書き換え**
>
> script.js 内の `firebaseConfig` を、Step 2-3でメモした自分のプロジェクトの設定に書き換えてください。
>
> ```javascript
> const firebaseConfig = {
>     apiKey: "AIzaSy...",           // ← 自分の値に書き換え
>     authDomain: "xxx.firebaseapp.com",  // ← 自分の値に書き換え
>     projectId: "your-project-id",  // ← 自分の値に書き換え
>     ...
> };
> ```

**4. package.json を設定**

1. 左側のファイル一覧で「package.json」をクリック
2. 既存の内容をすべて削除
3. [package.json](../code/nodejs/package.md) の内容をコピーして貼り付け

### 5-5. デプロイ

1. 画面下部の「作成」または「デプロイ」ボタンをクリック
2. デプロイが完了するまで待機（2〜5分程度）

> **デプロイ中の画面**
> - 青い円が回転している: デプロイ中
> - 緑のチェックマーク: デプロイ成功
> - 赤い×マーク: デプロイ失敗（ログを確認してください）

### 5-6. 関数URLの確認

1. デプロイ完了後、作成した関数名（`ai-chat-app`）をクリック
2. 画面上部に表示されるURLをメモ
   - 例: `https://ai-chat-app-xxxxx-an.a.run.app`
3. このURLをブラウザで開くと、ログイン画面が表示されます

> **独自ドメインを使いたい場合**
> 本番環境で `app.yourcompany.co.jp` のような独自ドメインを使いたい場合は、
> [99_custom_domain.md](99_custom_domain.md) を参照してください。

---

## Step 6: 動作確認（5分）

### 6-1. アクセス確認

| URL | 期待する結果 |
|-----|------------|
| `https://[関数URL]/` | ログイン画面が表示される |
| `https://[関数URL]/api/health` | `{"status":"ok","timestamp":"..."}` が表示される |

### 6-2. ログインテスト

1. 「Googleでログイン」ボタンをクリック
2. Googleアカウントを選択
3. ログイン成功後、チャット画面が表示される

### 6-3. チャットテスト

1. チャット画面でメッセージを入力
2. 「送信」ボタンをクリック
3. AIからの回答が表示されれば成功

> **ダミーAPIキーを使用している場合**
> `/api/health` は成功しますが、チャットは「AIの処理中にエラーが発生しました」と表示されます。
> 本番のOpenAI APIキーを設定すれば、チャットも動作します。

---

## 完了チェック

| チェック | 確認項目 |
|:------:|---------|
| ☐ | 関数URLにアクセスしてログイン画面が表示される |
| ☐ | Googleアカウントでログインできる |
| ☐ | ログイン後、チャット画面が表示される |
| ☐ | `/api/health` で `{"status":"ok"}` が表示される |
| ☐ | ブラウザに鍵マーク（HTTPS）が表示される |

---

## トラブルシューティング

### Cloud Run functionsのデプロイが失敗する
- Cloud Build APIが有効になっているか確認
- コードにエラーがないか確認（インデントのずれ等）
- ログを確認: Cloud Run →「ログ」タブ

### 「{"status": "ok"}」が表示されない
- 関数が正常にデプロイされているか確認（緑のチェックマーク）
- 「未認証の呼び出しを許可」が選択されているか確認
- 関数URLが正しいか確認

### チャットでエラーが出る
- OpenAI APIキーが正しく設定されているか確認
- Secret Managerのシークレット名が `openai-api-key` になっているか確認
- 環境変数名が `OPENAI_API_KEY` になっているか確認

### CORSエラーが出る
- コード内のCORS設定が正しいか確認
- `Access-Control-Allow-Origin: *` が設定されているか確認

---

## 重要なURL

| サービス | URL |
|---------|-----|
| GCPコンソール | https://console.cloud.google.com |
| Firebaseコンソール | https://console.firebase.google.com |
| OpenAI APIキー取得 | https://platform.openai.com/api-keys |

---

## 本番運用時のセキュリティ設定

本番環境で運用する際は、以下の設定を必ず行ってください。

### 必須設定

| 項目 | 現状（開発用） | 本番設定 |
|------|---------------|----------|
| CORS設定 | `'*'`（全許可） | 自分のドメインのみ許可に変更 |
| ALLOWED設定 | 未設定（全員許可） | `ALLOWED_EMAILS` または `ALLOWED_DOMAINS` を必ず設定 |
| Firebase設定 | サンプル値 | 自分のプロジェクトの値に書き換え |

#### CORS設定の変更方法

`backend.js` の以下の部分を変更します：

```javascript
// 変更前（開発用）
const ALLOWED_ORIGINS = ['*'];

// 変更後（本番用）- 自分のドメインのみ許可
const ALLOWED_ORIGINS = [
    'https://your-app.web.app',
    'https://your-domain.com'
];
```

#### アクセス制限の設定

GCPの環境変数で以下を設定します：

| 環境変数 | 設定例 | 説明 |
|---------|--------|------|
| `ALLOWED_EMAILS` | `admin@example.com,user1@example.com` | 許可するメールアドレス（カンマ区切り） |
| `ALLOWED_DOMAINS` | `@yourcompany.co.jp` | 許可するドメイン（@を含む、カンマ区切り） |

> **注意**: 両方とも未設定の場合、開発用として全員がアクセスできる状態になります。
> 本番では必ずどちらかを設定してください。

### 推奨設定（より安全に運用したい場合）

| 項目 | 説明 | 対応方法 |
|------|------|----------|
| JWT署名検証 | トークンの改ざん防止を強化 | `firebase-admin` パッケージで検証を追加 |
| レート制限 | 大量リクエスト攻撃の防止 | Cloud Armor を設定 |
| ログ監視 | 不正アクセスの検知 | Cloud Logging でアラート設定 |

> **補足**: 現在の実装でも基本的なセキュリティは確保されています。
> 上記は大規模運用や機密性の高いデータを扱う場合の追加対策です。

---

## 参考: 別のアーキテクチャパターン

より複雑なアプリケーションや長時間処理が必要な場合は、Cloud Runを使用する方法もあります。

詳細は [99_cloudrun.md](99_cloudrun.md) を参照してください。
